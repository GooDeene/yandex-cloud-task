# **Приложение "Гостевая книга"**

Здесь любой пользователь может оставить комментарий подписавшись каким-либо никнеймом.
На странице же отображаются все оставленные на текущий момент комментарии. 

Функционал удаления комментария не предусмотрен. Сортировка и временные метки не предусмотрены.


Если все необходимые сервисы запущены, приложение доступно по адресу: https://d5dfpcn58cs0luci6e84.apigw.yandexcloud.net


# **backend** 
- бэк составляющая приложения, сервер на питоне, развернутый с помощью InstanseGroup.

Реплицируется в 3 зоны доступности, далее скрывается за балансировщиком нагрузки - так получаем функционал
обращения каждый раз к разным репликам + немного отказоустойчивости. В случае повышения нагрузки на сервис или 
возникновения ошибок в инстансах, группа сама пересоздаст проблемные ВМ и поднимет новые на всремя повышенной нагрузки.

Свернут в docker-образ, который хранится в Container Registry, оттуда берется как образец для ВМ внутри группы.


# **frontend** 
- статичный файл index.html, размещенный в object storage. Фетчит данные с сервера и отрисовывает их. Отправляет post
запрос для добавления новых данных.


# **Архитектура и сервисы**

Данные приложения хранятся в YDB serverless, сервер их оттуда достает и туда записывает. Маршрутизация реализвоана через API Gateway,
он отдает статичный фронт или переадресует запросы на сервер по http. Сам шлюз доступен по HTTPS, что соответствует требованиям задания.
Благодаря использованию шлюза получается совмещать основную страницу, получаемую по HTTPS и запросы на сервер по HTTP (без шлюза это
приводило бы к ошибке при попыке фетчинга данных с сервера).

У шлюза статичный домен, это позволяет получать доступ к сайту не по прямому указанию IP и порта, а по домену.

P.S.: наметки по нереализованному:
1. Надо отображать версию фронта в UI, но фронт - просто файл разметки в хранилище. В хранилище есть метаданные у объектов, в том числе
lastModified - timestamp. Если как-то достать их или напрямую версию из функцинала "Версионирование бакета", можно было бы отображать его в UI
2. Есть идея это сделать, например, через Serverless Functions - вытаскивать метаданные объекта и возвращать как обычный запрос. 
Обработать такой запрос в шлюзе и вернуть в UI версию объека из бакета.

Реализовывать не пробовал, времени не хватило.